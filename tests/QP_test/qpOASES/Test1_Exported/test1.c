/* This file was automatically generated by pyNLControl.*/


#include <stdlib.h>
#include <math.h>
#include "qpOASES.hpp"
#include "test1_EVAL_CODE_Call.h"
#include "test1.h"


#include "mex.h"


void test1_Call(double *xGuess, double *a, double *b,  double *xOpt, double *Obj)
{
    USING_NAMESPACE_QPOASES

    
    real_t H[2*2], g[2], A[2*2], lbA[2], ubA[2], lbx[2], ubx[2];

    int nV = 2, nC = 2;

    test1_EVAL_CODE_Call_Func(a, b,  H, g, A, lbA, ubA, lbx, ubx);

    Options options;
    options.setToMPC();

    options.printLevel = PL_NONE;
    
    options.enableRamping = BT_TRUE;
    

    SQProblem qp(nV, nC);
    int_t nWSR;

    qp.setOptions(options);

    if (!qp.isInitialised())
    {
        nWSR = 5;
        qp.init(H, g, A, lbx, ubx, lbA, ubA,  nWSR, NULL, xGuess);
    }
    else
    {
        nWSR = 5;
        qp.hotstart(H, g, A, lbx, ubx, lbA, ubA,  nWSR, NULL);
    }

    qp.getPrimalSolution(xOpt);
    Obj[0] = qp.getObjVal();


}


void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    if (nrhs != 3)
    {
        mexErrMsgIdAndTxt("nrhs:", "3 outputs required.");
    }

    if (nlhs != 2)
    {
        mexErrMsgIdAndTxt("nrhs:", "2 inputs required.");
    }

    
    plhs[0] = mxCreateDoubleMatrix(2, 1, mxREAL);
    plhs[1] = mxCreateDoubleMatrix(1, 1, mxREAL);

    double *xGuess, *a, *b;

    double *xOpt, *Obj_VAL;

    
    xGuess = mxGetPr(prhs[0]);
    a = mxGetPr(prhs[1]);
    b = mxGetPr(prhs[2]);

    
    xOpt = mxGetPr(plhs[0]);
    Obj_VAL = mxGetPr(plhs[1]);

    test1_Call(xGuess, a, b, xOpt, Obj_VAL);
}